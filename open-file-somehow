#!/usr/bin/env bash
set -euo pipefail

# This is similar to xdg-query / xdg-open. It is much easier to customize
# and faster (xdg-open takes like .5 seconds for no reason). Still,
# xdg-open/xdg-query is used in some system apps (firefox?) which is 
# inconsistent but I can live with it.

args_to_lines() {
    for line in "$@"; do
        echo "$line"
    done
}

ask_the_user() {
    IFS=" "
    prompt="How should I open this?"
    args_to_lines "$@" | dmenu-provider -p "$prompt"
}

suitable_program_for() {
    filename="$1"
    ext="${1##*.}"

    # priority extensions
    case "$ext" in
        qpf|qsf|bsf|bdf) echo quartus; return;;
        desktop) echo dex; return;;
    esac

    mime="$(file -L --brief --mime-type "$filename")"
    case "$mime" in
        application/epub+zip)        echo zathura;;
        application/json)            ask_the_user "jq ." vim helix kwrite;;
        application/pdf)             echo zathura;;
        application/javascript)      echo "$EDITOR";;  # .lua is detected as this
        audio/*)                     echo mpv;;
        document/*)                  echo zathura;;
        html/*)                      echo firefox;;
        image/vnd.djvu)              echo zathura;;
        image/*)                     echo sxiv;;
        inode/directory)             echo dolphin;;
        inode/x-empty)               echo "$EDITOR";;
        text/html)                   ask_the_user firefox "$EDITOR";;
        text/*)                      echo "$EDITOR";;
        video/*)                     echo mpv;;
        application/vnd.ms-htmlhelp) echo xchm;;  # .chm files
        *)                           echo xdg-open;;
    esac
}

swallow_under_i3()
{
    if [ "${XDG_CURRENT_DESKTOP:-}" = "i3" ]; then
        echo "swallow"
    else
        echo ""
    fi
}

cmd_to_open() {
        
    program="$(suitable_program_for "$file")"

    case "$program" in
        zathura|sxiv|mpv|quartus|firefox|cvlc|vlc) 
            cmd="$(swallow_under_i3) $program"
        ;;
        lf)
            cmd="$termprefix $(swallow_under_i3) $program"
        ;;
        "$EDITOR") 
            if [ -w "$file" ]; then 
                 cmd="$termprefix $EDITOR"
             else
                 echo "Not writable, trying sudoedit..." >&2;
                 cmd="$termprefix sudoedit"
             fi
        ;;
        "") echo "bug in suitable-program-for, should return xdg-open" >&2; exit 1;;
        *) cmd="$termprefix $program";;
    esac

    echo "$cmd"
}

usage() {
    echo "usage:  $(basename "$0") [-t] [-n] file" >&2;
    echo "-n: don't actually run the cmd"
    echo "-t: open in a terminal"
}

main() {
    just_echo=0
    termprefix=""

    if [ "$1" = "-n" ]; then just_echo=1; shift; fi
    if [ "$1" = "-t" ]; then termprefix="$TERMINAL -e "; shift; fi
    if [ "$1" = "--help" -o "$1" = "-h" ]; then echo a; usage; exit 0; fi
    if [ -z "$1" ];           then echo b; usage; exit 1; fi

    file="$*"
    cmd=$(cmd_to_open "$file")

    echo "$cmd" "$file"
    settermtitle "$cmd" "$file"

    # cmd can be multiple words so it has to be unquoted
    # exec is used so this script is replaced with the program properly by bspswallow
    [ "$just_echo" -gt 0 ] || { exec $cmd "$file"; }

    mkdir -p "$HOME"/.local/state/bash
    echo "$cmd \"$file\"" >> "$HOME"/.local/state/bash/history;

}

main "$@"
