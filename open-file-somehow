#!/bin/sh
# ^ don't ever run shell scripts interactively with -i, this destroys your history.

# This is similar to xdg-query / xdg-open. It is much easier to customize
# and faster (xdg-open takes like .5 seconds for no reason). Still,
# xdg-open/xdg-query is used in some system apps (firefox?) which is 
# inconsistent but I can live with it.

args-to-lines() {
    for line in "$@"; do
        echo "$line"
    done
}

dmenu-with-opts() {
    IFS=" "
    prompt="How should I open this?"
    echo $(args-to-lines "$@") | dmenu -p "$prompt"
}

suitable-program-for() {
    filename="$1"
    ext="${1##*.}"

    # priority extensions
    case "$ext" in
        qpf|qsf|bsf|bdf) echo quartus; return;;
    esac

    mime=$(file -L -b --mime-type "$filename")
    case "$mime" in
        application/epub+zip) echo zathura;;
        application/json) dmenu-with-opts "jq ." vim helix kwrite;;
        application/pdf) echo zathura;;
        application/javascript) echo $EDITOR;;  # .lua is detected as this
        audio/*) echo command mpv;;
        document/*) echo zathura;;
        html/*) echo firefox;;
        image/vnd.djvu) echo zathura;;
        image/*) echo sxiv;;
        inode/directory) echo dolphin;;
        inode/x-empty) echo $EDITOR;;
        text/*) echo $EDITOR;;
        video/*) echo mpv;;
        application/vnd.ms-htmlhelp) echo kchmviewer;;
        *) echo xdg-open;;
    esac
}

swallow-under-i3()
{
    pgrep i3 >/dev/null && echo "swallow" || echo ""
}

cmd-to-open() {
    # echo "whattorun is run with these arguments:" >&2
    # echo "$@" >&2
        
    program="$(suitable-program-for "$file")"

    # echo "suitable-program-for returned $program for $file" >&2

    case "$program" in
        zathura|sxiv|mpv|quartus) 
            cmd="${termprefix} $(swallow-under-i3) $program"
        ;;
        $EDITOR) 
            if [ -w "$file" ]; then 
                 cmd="$termprefix $EDITOR"
             else
                 echo "Not writable, trying sudoedit..." >&2;
                 cmd="$termprefix sudoedit"
             fi
        ;;
        "") echo "bug in suitable-program-for, should return xdg-open" >&2; exit 1;;
        *) cmd="$termprefix $program";;
    esac

    echo "$cmd"
}

main() {
    [ "$1" = "-n" ] && { just_echo=1; shift; }
    [ "$1" = "-t" ] && { termprefix="$TERMINAL -e "; shift; }
    [ "$#" != 1 ] && { 
        echo "usage:  $(basename $0) [-t] [-n] file" >&2;
        echo "-n: don't actually run the cmd"
        echo "-t: open in a terminal"
    }

    file="$*"
    cmd=$(cmd-to-open "$file")

    #echo cmd is $cmd
    #echo file is $file

    echo $cmd "$file"
    # cmd can be multiple words so it has to be unquoted
    [ -n "$just_echo" ] || { $cmd "$file"; }

    # echo "command has ended"

    # don't really use this
    echo "$cmd \"$file\"" >> $HOME/.local/state/bash/history;

    # echo "exiting main"
}

#echo "arguments are $@"
main "$@"

# echo "this is literally the last line of the script"
